#!/bin/bash

## Functions

TUPA_UTILS="$(dirname "${0}")/tupa-utils"
# shellcheck source=./tupa-utils
{ [ -f "${TUPA_UTILS}" ] && source "${TUPA_UTILS}";} || exit 1


help() {
    echo "Usage: $(basename "$0") [-hqdcu] [-b DIR] DIR [DIR1 ...]"
    echo -e "\t-h\t\tDisplay help"
    echo -e "\t-q\t\tDo not print checksums"
    echo -e "\t-c\t\tCheck existing checksums"
    echo -e "\t-u\t\tUpdate changed checksums"
    echo -e "\t-f\t\tForce creation of a new checksum file even no changes detected"
    echo -e "\t-d\t\tAdd date to previous checksum version"
    echo -e "\t-b DIR\tBase directory for the operations"
#    echo -e "\t-A FILE\tFilename for aggregate file"
    exit 0
}

# Print file modification time
file_mdate() {
	date -r "${1}" +"%Y%m%d"
}


# print the files present in a checksum file in sorted order
chksum_files() {
	sed -E 's/([0-9a-f]+)[[:blank:]]+(.+)/\2/' -- "${1}" | sort
}

if [ ${#} -eq 0 ]; then
    help
fi

MODE="create"
QUIET=
FORCE=
BASEDIR=
DATE=
CHECKSUM=".checksum"

declare -a ALGO

while getopts 'hqdcufb:a:' option
do
# shellcheck disable=SC2220
    case "$option" in
    h)
         help
         ;;
    q)
        QUIET="--quiet"
        ;;
    c)
        MODE="check"
         ;;
    u)
        MODE="update"
         ;;
    d)
        DATE="yes"
         ;;
    f)
        FORCE="yes"
         ;;
    a)
	case "${OPTARG}" in
		b3)
			ALGO+=( "b3" )
		;;
		sha256)
			ALGO+=("sha256" )
		;;
		sha512)
			ALGO+=( "sha512" )
		;;
		md5)
			ALGO+=( "md5" )
		;;
		*)
			error "Unknown hash algorithm ${OPTARG}"
		;;
	esac
	;;
    b)
        BASEDIR="${OPTARG}"
        ;;
    esac
done

if (( ${#ALGO[@]} == 0 )); then
    ALGO+=( "b3" )
fi


# Read rest of the params
shift "$(( "$OPTIND" - 1 ))"

declare -a DIRS

while test "$#" -gt 0; do
        if [ -d "${1}" ]; then
                DIRS+=( "${1}" )
        fi
        shift
done

if [ -n "${BASEDIR}" ]; then
	pushd  "${BASEDIR}" > /dev/null || error "Cannot change into ${BASEDIR}" 
fi

set -u

# shellcheck disable=SC2094

for dir in "${DIRS[@]}"; do
	# cd "${dir}" || continue
	while read -r d; do
		pushd "${d}"  > /dev/null || continue
		echo "# Directory: ${d}"
		for alg in "${ALGO[@]}"; do
			CHECKSUM_FILE="${CHECKSUM}.${alg}"
			CHECKSUM_TMP="${CHECKSUM}.tmp"

			# clear previous interrupted run. Does not support parallel operation
			[ -f "${CHECKSUM_TMP}" ] && rm "${CHECKSUM_TMP}"

			if [ "${MODE}" = "check" ]; then
 				[ -f "${CHECKSUM_FILE}" ] || continue
				if [ -n "${QUIET}" ]; then
					"${alg}sum"  --check --quiet "${CHECKSUM_FILE}"
				else
					"${alg}sum"  --check "${CHECKSUM_FILE}"
				fi
				continue
			fi

			touch "${CHECKSUM_TMP}"
			if [ "${MODE}" = "update" ] && [ -s "${CHECKSUM_FILE}" ]; then

				# calculate checksum for files IN CHECKSUM_FILEmodified later than then CHECKSUM_FILE
				while read -r line; do
					file="$(echo "${line}" | sed -E 's/([0-9a-f]+)[[:blank:]]+(.+)/\2/')"
					if [ -f "${file}" ];then
						if [ "${file}" -nt "${CHECKSUM_FILE}" ]; then
							"${alg}sum" -- "${file}" >> "${CHECKSUM_TMP}"
						else
							echo "${line}" >> "${CHECKSUM_TMP}"
						fi
					fi
				done < "${CHECKSUM_FILE}"

				# calculate checksums for files not present in CHECKSUM_FILE
				comm -23 <(find . -maxdepth 1 -type f ! -name "${CHECKSUM}.*" -printf '%P\n' | sort) \
					  <( chksum_files  "${CHECKSUM_FILE}"  ) \
					| xargs -r  "${alg}sum" -- >> "${CHECKSUM_TMP}"
				# sort in-place
				sort -k 2 -o "${CHECKSUM_TMP}" "${CHECKSUM_TMP}"

			elif [ -n "${QUIET}" ] || [ "${MODE}" = "update" ]; then
				find . -maxdepth 1 -type f ! -name "${CHECKSUM}.*" -printf '%P\0' | sort -z | xargs -r -0 "${alg}sum" -- > "${CHECKSUM_TMP}"
			else
				find . -maxdepth 1 -type f ! -name "${CHECKSUM}.*" -printf '%P\0' | sort -z | xargs -r -0 "${alg}sum" -- | tee "${CHECKSUM_TMP}"
			fi

			if [ "${MODE}" = "check" ] && [ -n "${FORCE}" ] || [ "${MODE}" = "update" ]; then
				if [ -f "${CHECKSUM_FILE}" ]; then
				# keep the old checksum file if there isn't any difference
					diff "${CHECKSUM_FILE}" "${CHECKSUM_TMP}" | grep  '^[<>]'
					if [ "${PIPESTATUS[0]}" = "0" ]; then
						touch  "${CHECKSUM_FILE}"
						rm "${CHECKSUM_TMP}"
						continue
					fi
				fi
			fi

			if [ -n "${DATE}" ] && [ -f "${CHECKSUM_FILE}" ]; then
				mv "${CHECKSUM_FILE}" "${CHECKSUM_FILE}_$(file_mdate "${CHECKSUM_FILE}")"
			fi

			mv "${CHECKSUM_TMP}" "${CHECKSUM_FILE}"
			# delete empty checksum files
			[ ! -s "${CHECKSUM_FILE}" ] && rm "${CHECKSUM_FILE}"

		done
		popd > /dev/null || error "Could not return to dir"
	done < <(find  "${dir}" -type d)
done

if [ -n "${BASEDIR}" ]; then
	popd > /dev/null  || error "Could not return to dir"
fi
